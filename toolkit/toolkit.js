// Generated by CoffeeScript 1.3.1
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  (function(window, document) {
    var AP, G, OP, class2type, dumpFnDict, getInt, hasOwn, indexOf, slice, toString, _ref;
    _ref = [Object.prototype, Array.prototype], OP = _ref[0], AP = _ref[1];
    window.G = G = function(queryId) {
      return document.getElementById(queryId);
    };
    if (window.define != null) {
      define(function(require, exports, module) {
        return G;
      });
    } else {
      if (window.G != null) {
        G.old = window.G;
      }
      window.G = G;
    }
    G.t = function(tagName) {
      return document.getElementsByTagName(tagName);
    };
    slice = AP.slice;
    toString = OP.toString;
    hasOwn = OP.hasOwnProperty;
    class2type = {};
    'Arguments Function Number String Date RegExp Array Boolean Object'.replace(/[^, ]+/g, function(typeName) {
      class2type["[object " + typeName + "]"] = typeName.toLowerCase();
      return G["is" + typeName] = function(obj) {
        return toString.call(obj) === ("[object " + typeName + "]");
      };
    });
    G.extend = function() {
      var clone, copy, copyIsArray, deep, i, length, name, options, src, target, _i, _ref1, _ref2;
      target = arguments[0] || {};
      length = arguments.length;
      deep = false;
      i = 1;
      if (G.isBoolean(target)) {
        deep = target;
        target = arguments[1];
        i = 2;
      }
      if (typeof target !== "object" && !G.isFunction(target)) {
        target = {};
      }
      if (length === i) {
        _ref1 = [this, i - 1], target = _ref1[0], i = _ref1[1];
      }
      for (i = _i = i, _ref2 = arguments.length; i <= _ref2 ? _i < _ref2 : _i > _ref2; i = i <= _ref2 ? ++_i : --_i) {
        if ((options = arguments[i]) != null) {
          for (name in options) {
            copy = options[name];
            src = target[name];
            if (target === copy) {
              continue;
            }
            if (deep && copy && (G.isPlainObject(copy) || (copyIsArray = G.isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && (G.isArray(src) ? src : []);
              } else {
                clone = src && (G.isPlainObject(src) ? src : {});
              }
              target[name] = G.extend(deep, clone, copy);
            } else if (copy !== void 0) {
              target[name] = copy;
            }
          }
        }
      }
      return target;
    };
    G.extend({
      toType: function(obj) {
        if (obj == null) {
          return String(obj);
        } else {
          return class2type[toString.call(obj)] || "object";
        }
      },
      isWindow: function(obj) {
        return (obj != null) && obj === obj.window;
      },
      isNode: function(obj) {
        return obj.nodeType != null;
      },
      isElement: function(obj) {
        return (obj != null) && obj.nodeType === 1;
      },
      isFinite: function(obj) {
        return G.isNumber(obj) && isFinite(obj);
      },
      isObject: function(obj) {
        return obj === Object(obj);
      },
      isNaN: function(obj) {
        return obj !== obj;
      },
      isNull: function(obj) {
        return obj === null;
      },
      isUndefined: function(obj) {
        return obj === void 0;
      },
      isEmpty: function(obj) {
        var key;
        if (obj == null) {
          return true;
        }
        if (G.isArray(obj) || G.isString(obj)) {
          return obj.length === 0;
        }
        for (key in obj) {
          if (G.has(obj, key)) {
            return false;
          }
        }
        return true;
      },
      isPlainObject: function(obj) {
        var key;
        if (!obj || G.toType(obj) !== "object" || obj.nodeType || G.isWindow(obj)) {
          return false;
        }
        try {
          if (obj.constructor && !G.has(obj, "constructor") && !G.has(obj.constructor.prototype, "isPrototypeOf")) {
            return false;
          }
        } catch (e) {
          return false;
        }
        for (key in obj) {
          key;

        }
        return key === void 0 || G.has(obj, key);
      }
    });
    G.extend({
      has: function(obj, attr) {
        return hasOwn.call(obj, attr);
      },
      toArray: function(obj) {
        var k, v, _results;
        if (obj == null) {
          return [];
        }
        if (G.isArray(obj)) {
          return slice.call(obj);
        }
        if (G.isArguments(obj)) {
          return slice.call(obj);
        }
        if ((obj.toArray != null) && G.isFunction(obj.toArray)) {
          return obj.toArray();
        }
        _results = [];
        for (k in obj) {
          v = obj[k];
          _results.push(v);
        }
        return _results;
      }
    });
    G.extend({
      charUpperCase: function(index, length) {
        var i, newIndex, strList, _i;
        if (length == null) {
          length = 1;
        }
        strList = this.split('');
        for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
          newIndex = index + i;
          strList[newIndex] = strList[newIndex].toUpperCase();
        }
        return strList.join('');
      },
      getDelta: function(oldStr, newStr) {
        var contr, deling, delingIndex, delta, i, resultList, _i, _len;
        resultList = [];
        delta = '';
        delingIndex = 0;
        contr = function(oldStr, newStr, index) {
          var _results;
          _results = [];
          while (newStr[index] !== oldStr[index]) {
            delta += newStr[index];
            _results.push(newStr = newStr.remove(index));
          }
          return _results;
        };
        deling = function(oldStr, newStr, index) {
          var _ref1;
          if (_ref1 = newStr[index], __indexOf.call(oldStr, _ref1) < 0) {
            oldStr = oldStr.remove(delingIndex);
            newStr = newStr.remove(index);
            return deling(index);
          }
        };
        for (_i = 0, _len = newStr.length; _i < _len; _i++) {
          i = newStr[_i];
          if (oldStr.length) {
            deling(i);
          }
        }
        return [oldStr, newStr];
      }
    });
    dumpFnDict = {};
    G.extend({
      arr2str: dumpFnDict.Array2str = function(arr) {
        var resultStr, v, _i, _len;
        resultStr = "[";
        for (_i = 0, _len = arr.length; _i < _len; _i++) {
          v = arr[_i];
          resultStr += "" + (G.dump(v)) + ",";
        }
        return resultStr.slice(0, -1) + "]";
      },
      obj2str: dumpFnDict.Object2str = function(obj) {
        var k, resultStr, v;
        resultStr = "{";
        for (k in obj) {
          v = obj[k];
          if (G.has(obj, k)) {
            resultStr += "" + (G.dump(k)) + ":" + (G.dump(v)) + ",";
          }
        }
        return resultStr.slice(0, -1) + "}";
      },
      dump: function(obj) {
        var type, _i, _len, _ref1;
        dumpFnDict["String2str"] = function(string) {
          if (G.isString(string)) {
            return '"' + string + '"';
          } else {
            return string;
          }
        };
        _ref1 = ["Object", "Array", "String"];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          type = _ref1[_i];
          if (G["is" + type](obj)) {
            return dumpFnDict["" + type + "2str"](obj);
          }
        }
        return obj;
      },
      param: function(obj) {
        var attr, queryArray, tmpStr, value;
        queryArray = [];
        tmpStr = "";
        for (attr in obj) {
          value = obj[attr];
          tmpStr = encodeURIComponent(attr) + "=" + encodeURIComponent(G.dump(value));
          queryArray.push(tmpStr);
        }
        return queryArray.join("&");
      }
    });
    indexOf = AP.indexOf;
    G.extend({
      addClass: function(elem, className) {
        var elemClass;
        elemClass = "" + (elem.getAttribute("class") || "") + " ";
        if (!~indexOf.call(elemClass, className)) {
          elem.setAttribute("class", elemClass + className);
        }
        return this;
      },
      removeClass: function(elem, className) {
        var elemClass;
        elemClass = elem.getAttribute("class") || "";
        elem.setAttribute("class", "" + (elemClass.replace(new RegExp("\\s*" + className + "\\s*"), "")));
        return this;
      },
      getCSS: function(elem, styleName) {
        var elemStyle;
        elemStyle = document.defaultView != null ? document.defaultView.getComputedStyle(elem) : elem.currentStyle;
        if (styleName == null) {
          elemStyle;

        } else if (styleName !== "float") {
          elemStyle[styleName];
        } else {
          elemStyle["cssFloat"] || elemStyle["styleFloat"];
        }
        return this;
      },
      setCSS: function(elem, styleName, styleValue) {
        var elemStyle;
        elemStyle = elem.style;
        elemStyle.cssText = elemStyle.cssText.replace(new RegExp("\s*" + styleName + "\s*:.*;+\s", "g"), "");
        elemStyle.cssText += "" + styleName + ": " + styleValue + ";";
        return this;
      }
    });
    getInt = function(str, hex) {
      if (hex == null) {
        hex = 10;
      }
      if (str === "") {
        return 0;
      }
      return parseInt(str, hex);
    };
    return G.localStorage = (function(window) {
      var getCookie, getLocalStorage, getMethod, ls, setCookie, setLocalStorage, setMethod, ss, storageTime, useCookie, useSession, _ref1;
      ls = window.localStorage;
      ss = window.sessionStorage;
      useCookie = false;
      useSession = false;
      storageTime = "30d";
      getCookie = function(key) {
        var re, result;
        re = new RegExp("\\??" + key + "=([^;]*)", "g");
        if ([result = re.exec(document.cookie)][0] != null) {
          return unescape(result[1]);
        } else {
          return null;
        }
      };
      setCookie = function(key, value, time) {
        var cookieStr, exp, getTime, outTime;
        getTime = function(str) {
          var timeCount, timeUnit;
          timeCount = getInt(str.slice(0, -1));
          timeUnit = str.substr(-1);
          switch (timeUnit) {
            case "s":
              return timeCount * 1000;
            case "h":
              return timeCount * 60 * 60 * 1000;
            case "d":
              return timeCount * 24 * 60 * 60 * 1000;
            default:
              return useSession = true;
          }
        };
        outTime = getTime(time);
        cookieStr = "" + key + "=" + (escape(value));
        [exp = new Date()][0].setTime(exp.getTime() + outTime);
        if (!useSession) {
          cookieStr += ";expires=" + (exp.toGMTString());
        }
        cookieStr += ";path=/";
        return document.cookie = cookieStr;
      };
      getLocalStorage = function(key) {
        var storage;
        storage = useSession ? ss : ls;
        return storage[key];
      };
      setLocalStorage = function(key, value) {
        var storage;
        storage = useSession ? ss : ls;
        return storage[key] = value;
      };
      _ref1 = ls != null ? [getLocalStorage, setLocalStorage] : [getCookie, setCookie], getMethod = _ref1[0], setMethod = _ref1[1];
      return {
        get: function() {
          var args, result, storageKey, storageValue, _i, _len;
          if (useCookie) {
            getMethod = getCookie;
          }
          args = G.isArray(arguments[0]) ? arguments[0] : G.toArray(arguments);
          if (args.length === 1) {
            return getMethod(args[0]);
          }
          result = {};
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            storageKey = args[_i];
            storageValue = getMethod(storageKey);
            if (storageValue != null) {
              result[storageKey] = storageValue;
            }
          }
          return result;
        },
        set: function() {
          var key, value, _ref2;
          if (useCookie) {
            setMethod = setCookie;
          }
          if (G.isObject(arguments[0])) {
            _ref2 = arguments[0];
            for (key in _ref2) {
              value = _ref2[key];
              setMethod(key, value, storageTime);
            }
          } else {
            key = arguments[0], value = arguments[1];
            if ((key != null) && (value != null)) {
              setMethod(key, value, storageTime);
            }
          }
          return this;
        },
        storageTime: function(time) {
          var _ref2, _ref3, _ref4;
          if ((_ref2 = getInt(time)) === 0 || _ref2 === NaN) {
            return useSession = true, this;
          }
          if (G.isNumber(time)) {
            time = "" + time + "s";
          }
          if ((_ref3 = time.slice(-1)) === "s" || _ref3 === "h" || _ref3 === "d") {
            return useSession = true, this;
          }
          _ref4 = [time, false], storageTime = _ref4[0], useSession = _ref4[1];
          return this;
        },
        useCookie: function(boolInput) {
          useCookie = boolInput;
          return this;
        }
      };
    })(window);
  })(window, document);

}).call(this);
